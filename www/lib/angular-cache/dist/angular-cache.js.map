{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 8a05c295a6019ef8c7eb","webpack:///./src/index.js","webpack:///external \"angular\"","webpack:///../CacheFactory/dist/cachefactory.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACtCA,KAAM,UAAU,oBAAQ,CAAR,CAAV;AACN,KAAM,eAAe,oBAAQ,CAAR,CAAf;;AAEN,cAAa,KAAb,CAAmB,MAAnB,GAA4B,QAAQ,MAAR;AAC5B,cAAa,KAAb,CAAmB,QAAnB,GAA8B,QAAQ,QAAR;AAC9B,cAAa,KAAb,CAAmB,QAAnB,GAA8B,QAAQ,QAAR;;AAE9B,UAAS,kBAAT,GAA+B;AAC7B,QAAK,IAAL,GAAY,YAAY;AAAE,YAAO,aAAa,UAAb,CAAT;IAAZ,CADiB;EAA/B;;AAIA,UAAS,oBAAT,GAAiC;AAC/B,QAAK,QAAL,GAAgB,aAAa,QAAb,CADe;AAE/B,QAAK,QAAL,CAAc,aAAd,GAA8B,uBAA9B,CAF+B;;AAI/B,QAAK,IAAL,GAAY,CAAC,IAAD,EAAO,UAAU,EAAV,EAAc;AAC/B,kBAAa,KAAb,CAAmB,OAAnB,GAA6B,EAA7B,CAD+B;AAE/B,YAAO,YAAP,CAF+B;IAAd,CAAnB,CAJ+B;EAAjC;;AAUA,SAAQ,MAAR,CAAe,eAAf,EAAgC,EAAhC,EACG,QADH,CACY,YADZ,EAC0B,kBAD1B,EAEG,QAFH,CAEY,cAFZ,EAE4B,oBAF5B;;AAIA,QAAO,OAAP,GAAiB,eAAjB;AACA,KAAI;AACF,UAAO,OAAP,CAAe,IAAf,GAAsB,eAAtB,CADE;EAAJ,CAEE,OAAO,GAAP,EAAY,E;;;;;;AC5Bd,gD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA,sGAAqG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE/O;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;;AAEZ;AACA;AACA;AACA,WAAU;;AAEV;AACA,SAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA,SAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,WAAU;AACV,SAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA;;AAEA,gCAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,yBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA,SAAQ;AACR;;AAEA,sDAAqD;;AAErD;AACA;AACA,WAAU;AACV;AACA,OAAM;AACN;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA,SAAQ;AACR;;AAEA,qBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ,WAAU;AACV,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA,WAAU;AACV;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,SAAQ;AACR;AACA,yBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,uBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF,sCAAqC;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA,EAAC;AACD;AACA,yC","file":"./dist/angular-cache.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"angular-cache\", [\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularCacheModuleName\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"angularCacheModuleName\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8a05c295a6019ef8c7eb\n **/","const angular = require('angular')\nconst CacheFactory = require('cachefactory')\n\nCacheFactory.utils.equals = angular.equals\nCacheFactory.utils.isObject = angular.isObject\nCacheFactory.utils.fromJson = angular.fromJson\n\nfunction BinaryHeapProvider () {\n  this.$get = function () { return CacheFactory.BinaryHeap }\n}\n\nfunction CacheFactoryProvider () {\n  this.defaults = CacheFactory.defaults\n  this.defaults.storagePrefix = 'angular-cache.caches.'\n\n  this.$get = ['$q', function ($q) {\n    CacheFactory.utils.Promise = $q\n    return CacheFactory\n  }]\n}\n\nangular.module('angular-cache', [])\n  .provider('BinaryHeap', BinaryHeapProvider)\n  .provider('CacheFactory', CacheFactoryProvider)\n\nmodule.exports = 'angular-cache'\ntry {\n  module.exports.name = 'angular-cache'\n} catch (err) {\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0\n **/","/*!\n * cachefactory\n * @version 1.4.0 - Homepage <https://github.com/jmdobry/CacheFactory>\n * @author Jason Dobry <jason.dobry@gmail.com>\n * @copyright (c) 2013-2016 Jason Dobry \n * @license MIT <https://github.com/jmdobry/CacheFactory/blob/master/LICENSE>\n * \n * @overview CacheFactory is a very simple and useful cache for the browser.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cachefactory\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CacheFactory\"] = factory();\n\telse\n\t\troot[\"CacheFactory\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar BinaryHeap = __webpack_require__(1);\n\tvar _Promise = null;\n\ttry {\n\t  _Promise = window.Promise;\n\t} catch (e) {}\n\t\n\tvar utils = {\n\t  isNumber: function isNumber(value) {\n\t    return typeof value === 'number';\n\t  },\n\t  isString: function isString(value) {\n\t    return typeof value === 'string';\n\t  },\n\t  isObject: function isObject(value) {\n\t    return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n\t  },\n\t  isFunction: function isFunction(value) {\n\t    return typeof value === 'function';\n\t  },\n\t  fromJson: function fromJson(value) {\n\t    return JSON.parse(value);\n\t  },\n\t  equals: function equals(a, b) {\n\t    return a === b;\n\t  },\n\t\n\t  Promise: _Promise\n\t};\n\t\n\tfunction _keys(collection) {\n\t  var keys = [];\n\t  var key = undefined;\n\t  if (!utils.isObject(collection)) {\n\t    return keys;\n\t  }\n\t  for (key in collection) {\n\t    if (collection.hasOwnProperty(key)) {\n\t      keys.push(key);\n\t    }\n\t  }\n\t  return keys;\n\t}\n\t\n\tfunction _isPromiseLike(value) {\n\t  return value && typeof value.then === 'function';\n\t}\n\t\n\tfunction _stringifyNumber(number) {\n\t  if (utils.isNumber(number)) {\n\t    return number.toString();\n\t  }\n\t  return number;\n\t}\n\t\n\tfunction _keySet(collection) {\n\t  var keySet = {};\n\t  var key = undefined;\n\t  if (!utils.isObject(collection)) {\n\t    return keySet;\n\t  }\n\t  for (key in collection) {\n\t    if (collection.hasOwnProperty(key)) {\n\t      keySet[key] = key;\n\t    }\n\t  }\n\t  return keySet;\n\t}\n\t\n\tvar defaults = {\n\t  capacity: Number.MAX_VALUE,\n\t  maxAge: Number.MAX_VALUE,\n\t  deleteOnExpire: 'none',\n\t  onExpire: null,\n\t  cacheFlushInterval: null,\n\t  recycleFreq: 1000,\n\t  storageMode: 'memory',\n\t  storageImpl: null,\n\t  disabled: false,\n\t  storagePrefix: 'cachefactory.caches.',\n\t  storeOnResolve: false,\n\t  storeOnReject: false\n\t};\n\t\n\tvar caches = {};\n\t\n\tfunction createCache(cacheId, options) {\n\t  if (cacheId in caches) {\n\t    throw new Error(cacheId + ' already exists!');\n\t  } else if (!utils.isString(cacheId)) {\n\t    throw new Error('cacheId must be a string!');\n\t  }\n\t\n\t  var $$data = {};\n\t  var $$promises = {};\n\t  var $$storage = null;\n\t  var $$expiresHeap = new BinaryHeap(function (x) {\n\t    return x.expires;\n\t  }, utils.equals);\n\t  var $$lruHeap = new BinaryHeap(function (x) {\n\t    return x.accessed;\n\t  }, utils.equals);\n\t\n\t  var cache = caches[cacheId] = {\n\t\n\t    $$id: cacheId,\n\t\n\t    destroy: function destroy() {\n\t      clearInterval(this.$$cacheFlushIntervalId);\n\t      clearInterval(this.$$recycleFreqId);\n\t      this.removeAll();\n\t      if ($$storage) {\n\t        $$storage().removeItem(this.$$prefix + '.keys');\n\t        $$storage().removeItem(this.$$prefix);\n\t      }\n\t      $$storage = null;\n\t      $$data = null;\n\t      $$lruHeap = null;\n\t      $$expiresHeap = null;\n\t      this.$$prefix = null;\n\t      delete caches[this.$$id];\n\t    },\n\t    disable: function disable() {\n\t      this.$$disabled = true;\n\t    },\n\t    enable: function enable() {\n\t      delete this.$$disabled;\n\t    },\n\t    get: function get(key, options) {\n\t      var _this2 = this;\n\t\n\t      if (Array.isArray(key)) {\n\t        var _ret = function () {\n\t          var keys = key;\n\t          var values = [];\n\t\n\t          keys.forEach(function (key) {\n\t            var value = _this2.get(key, options);\n\t            if (value !== null && value !== undefined) {\n\t              values.push(value);\n\t            }\n\t          });\n\t\n\t          return {\n\t            v: values\n\t          };\n\t        }();\n\t\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t      } else {\n\t        key = _stringifyNumber(key);\n\t\n\t        if (this.$$disabled) {\n\t          return;\n\t        }\n\t      }\n\t\n\t      options = options || {};\n\t      if (!utils.isString(key)) {\n\t        throw new Error('key must be a string!');\n\t      } else if (options && !utils.isObject(options)) {\n\t        throw new Error('options must be an object!');\n\t      } else if (options.onExpire && !utils.isFunction(options.onExpire)) {\n\t        throw new Error('options.onExpire must be a function!');\n\t      }\n\t\n\t      var item = undefined;\n\t\n\t      if ($$storage) {\n\t        if ($$promises[key]) {\n\t          return $$promises[key];\n\t        }\n\t\n\t        var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);\n\t\n\t        if (itemJson) {\n\t          item = utils.fromJson(itemJson);\n\t        } else {\n\t          return;\n\t        }\n\t      } else if (utils.isObject($$data)) {\n\t        if (!(key in $$data)) {\n\t          return;\n\t        }\n\t\n\t        item = $$data[key];\n\t      }\n\t\n\t      var value = item.value;\n\t      var now = new Date().getTime();\n\t\n\t      if ($$storage) {\n\t        $$lruHeap.remove({\n\t          key: key,\n\t          accessed: item.accessed\n\t        });\n\t        item.accessed = now;\n\t        $$lruHeap.push({\n\t          key: key,\n\t          accessed: now\n\t        });\n\t      } else {\n\t        $$lruHeap.remove(item);\n\t        item.accessed = now;\n\t        $$lruHeap.push(item);\n\t      }\n\t\n\t      if (this.$$deleteOnExpire === 'passive' && 'expires' in item && item.expires < now) {\n\t        this.remove(key);\n\t\n\t        if (this.$$onExpire) {\n\t          this.$$onExpire(key, item.value, options.onExpire);\n\t        } else if (options.onExpire) {\n\t          options.onExpire.call(this, key, item.value);\n\t        }\n\t        value = undefined;\n\t      } else if ($$storage) {\n\t        $$storage().setItem(this.$$prefix + '.data.' + key, JSON.stringify(item));\n\t      }\n\t\n\t      return value;\n\t    },\n\t    info: function info(key) {\n\t      if (key) {\n\t        var item = undefined;\n\t        if ($$storage) {\n\t          var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);\n\t\n\t          if (itemJson) {\n\t            item = utils.fromJson(itemJson);\n\t            return {\n\t              created: item.created,\n\t              accessed: item.accessed,\n\t              expires: item.expires,\n\t              isExpired: new Date().getTime() - item.created > (item.maxAge || this.$$maxAge)\n\t            };\n\t          } else {\n\t            return undefined;\n\t          }\n\t        } else if (utils.isObject($$data) && key in $$data) {\n\t          item = $$data[key];\n\t\n\t          return {\n\t            created: item.created,\n\t            accessed: item.accessed,\n\t            expires: item.expires,\n\t            isExpired: new Date().getTime() - item.created > (item.maxAge || this.$$maxAge)\n\t          };\n\t        } else {\n\t          return undefined;\n\t        }\n\t      } else {\n\t        return {\n\t          id: this.$$id,\n\t          capacity: this.$$capacity,\n\t          maxAge: this.$$maxAge,\n\t          deleteOnExpire: this.$$deleteOnExpire,\n\t          onExpire: this.$$onExpire,\n\t          cacheFlushInterval: this.$$cacheFlushInterval,\n\t          recycleFreq: this.$$recycleFreq,\n\t          storageMode: this.$$storageMode,\n\t          storageImpl: $$storage ? $$storage() : undefined,\n\t          disabled: !!this.$$disabled,\n\t          size: $$lruHeap && $$lruHeap.size() || 0\n\t        };\n\t      }\n\t    },\n\t    keys: function keys() {\n\t      if ($$storage) {\n\t        var keysJson = $$storage().getItem(this.$$prefix + '.keys');\n\t\n\t        if (keysJson) {\n\t          return utils.fromJson(keysJson);\n\t        } else {\n\t          return [];\n\t        }\n\t      } else {\n\t        return _keys($$data);\n\t      }\n\t    },\n\t    keySet: function keySet() {\n\t      if ($$storage) {\n\t        var keysJson = $$storage().getItem(this.$$prefix + '.keys');\n\t        var kSet = {};\n\t\n\t        if (keysJson) {\n\t          var keys = utils.fromJson(keysJson);\n\t\n\t          for (var i = 0; i < keys.length; i++) {\n\t            kSet[keys[i]] = keys[i];\n\t          }\n\t        }\n\t        return kSet;\n\t      } else {\n\t        return _keySet($$data);\n\t      }\n\t    },\n\t    put: function put(key, value, options) {\n\t      var _this3 = this;\n\t\n\t      options || (options = {});\n\t\n\t      var storeOnResolve = 'storeOnResolve' in options ? !!options.storeOnResolve : this.$$storeOnResolve;\n\t      var storeOnReject = 'storeOnReject' in options ? !!options.storeOnReject : this.$$storeOnReject;\n\t\n\t      var getHandler = function getHandler(store, isError) {\n\t        return function (v) {\n\t          if (store) {\n\t            delete $$promises[key];\n\t            if (utils.isObject(v) && 'status' in v && 'data' in v) {\n\t              v = [v.status, v.data, v.headers(), v.statusText];\n\t              _this3.put(key, v);\n\t            } else {\n\t              _this3.put(key, v);\n\t            }\n\t          }\n\t          if (isError) {\n\t            if (utils.Promise) {\n\t              return utils.Promise.reject(v);\n\t            } else {\n\t              throw v;\n\t            }\n\t          } else {\n\t            return v;\n\t          }\n\t        };\n\t      };\n\t\n\t      if (this.$$disabled || !utils.isObject($$data) || value === null || value === undefined) {\n\t        return;\n\t      }\n\t      key = _stringifyNumber(key);\n\t\n\t      if (!utils.isString(key)) {\n\t        throw new Error('key must be a string!');\n\t      }\n\t\n\t      var now = new Date().getTime();\n\t      var item = {\n\t        key: key,\n\t        value: _isPromiseLike(value) ? value.then(getHandler(storeOnResolve, false), getHandler(storeOnReject, true)) : value,\n\t        created: options.created === undefined ? now : options.created,\n\t        accessed: options.accessed === undefined ? now : options.accessed\n\t      };\n\t      if (options.maxAge) {\n\t        item.maxAge = options.maxAge;\n\t      }\n\t\n\t      if (options.expires === undefined) {\n\t        item.expires = item.created + (item.maxAge || this.$$maxAge);\n\t      } else {\n\t        item.expires = options.expires;\n\t      }\n\t\n\t      if ($$storage) {\n\t        if (_isPromiseLike(item.value)) {\n\t          $$promises[key] = item.value;\n\t          return $$promises[key];\n\t        }\n\t        var keysJson = $$storage().getItem(this.$$prefix + '.keys');\n\t        var keys = keysJson ? utils.fromJson(keysJson) : [];\n\t        var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);\n\t\n\t        // Remove existing\n\t        if (itemJson) {\n\t          this.remove(key);\n\t        }\n\t        // Add to expires heap\n\t        $$expiresHeap.push({\n\t          key: key,\n\t          expires: item.expires\n\t        });\n\t        // Add to lru heap\n\t        $$lruHeap.push({\n\t          key: key,\n\t          accessed: item.accessed\n\t        });\n\t        // Set item\n\t        $$storage().setItem(this.$$prefix + '.data.' + key, JSON.stringify(item));\n\t        var exists = false;\n\t        for (var i = 0; i < keys.length; i++) {\n\t          if (keys[i] === key) {\n\t            exists = true;\n\t            break;\n\t          }\n\t        }\n\t        if (!exists) {\n\t          keys.push(key);\n\t        }\n\t        $$storage().setItem(this.$$prefix + '.keys', JSON.stringify(keys));\n\t      } else {\n\t        // Remove existing\n\t        if ($$data[key]) {\n\t          this.remove(key);\n\t        }\n\t        // Add to expires heap\n\t        $$expiresHeap.push(item);\n\t        // Add to lru heap\n\t        $$lruHeap.push(item);\n\t        // Set item\n\t        $$data[key] = item;\n\t        delete $$promises[key];\n\t      }\n\t\n\t      // Handle exceeded capacity\n\t      if ($$lruHeap.size() > this.$$capacity) {\n\t        this.remove($$lruHeap.peek().key);\n\t      }\n\t\n\t      return value;\n\t    },\n\t    remove: function remove(key) {\n\t      key += '';\n\t      delete $$promises[key];\n\t      if ($$storage) {\n\t        var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);\n\t\n\t        if (itemJson) {\n\t          var item = utils.fromJson(itemJson);\n\t          $$lruHeap.remove({\n\t            key: key,\n\t            accessed: item.accessed\n\t          });\n\t          $$expiresHeap.remove({\n\t            key: key,\n\t            expires: item.expires\n\t          });\n\t          $$storage().removeItem(this.$$prefix + '.data.' + key);\n\t          var keysJson = $$storage().getItem(this.$$prefix + '.keys');\n\t          var keys = keysJson ? utils.fromJson(keysJson) : [];\n\t          var index = keys.indexOf(key);\n\t\n\t          if (index >= 0) {\n\t            keys.splice(index, 1);\n\t          }\n\t          $$storage().setItem(this.$$prefix + '.keys', JSON.stringify(keys));\n\t          return item.value;\n\t        }\n\t      } else if (utils.isObject($$data)) {\n\t        var value = $$data[key] ? $$data[key].value : undefined;\n\t        $$lruHeap.remove($$data[key]);\n\t        $$expiresHeap.remove($$data[key]);\n\t        $$data[key] = null;\n\t        delete $$data[key];\n\t        return value;\n\t      }\n\t    },\n\t    removeAll: function removeAll() {\n\t      if ($$storage) {\n\t        $$lruHeap.removeAll();\n\t        $$expiresHeap.removeAll();\n\t        var keysJson = $$storage().getItem(this.$$prefix + '.keys');\n\t\n\t        if (keysJson) {\n\t          var keys = utils.fromJson(keysJson);\n\t\n\t          for (var i = 0; i < keys.length; i++) {\n\t            this.remove(keys[i]);\n\t          }\n\t        }\n\t        $$storage().setItem(this.$$prefix + '.keys', JSON.stringify([]));\n\t      } else if (utils.isObject($$data)) {\n\t        $$lruHeap.removeAll();\n\t        $$expiresHeap.removeAll();\n\t        for (var key in $$data) {\n\t          $$data[key] = null;\n\t        }\n\t        $$data = {};\n\t      } else {\n\t        $$lruHeap.removeAll();\n\t        $$expiresHeap.removeAll();\n\t        $$data = {};\n\t      }\n\t      $$promises = {};\n\t    },\n\t    removeExpired: function removeExpired() {\n\t      var now = new Date().getTime();\n\t      var expired = {};\n\t      var key = undefined;\n\t      var expiredItem = undefined;\n\t\n\t      while ((expiredItem = $$expiresHeap.peek()) && expiredItem.expires <= now) {\n\t        expired[expiredItem.key] = expiredItem.value ? expiredItem.value : null;\n\t        $$expiresHeap.pop();\n\t      }\n\t\n\t      if ($$storage) {\n\t        for (key in expired) {\n\t          var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);\n\t          if (itemJson) {\n\t            expired[key] = utils.fromJson(itemJson).value;\n\t            this.remove(key);\n\t          }\n\t        }\n\t      } else {\n\t        for (key in expired) {\n\t          this.remove(key);\n\t        }\n\t      }\n\t\n\t      if (this.$$onExpire) {\n\t        for (key in expired) {\n\t          this.$$onExpire(key, expired[key]);\n\t        }\n\t      }\n\t\n\t      return expired;\n\t    },\n\t    setCacheFlushInterval: function setCacheFlushInterval(cacheFlushInterval) {\n\t      var _this = this;\n\t      if (cacheFlushInterval === null) {\n\t        delete _this.$$cacheFlushInterval;\n\t      } else if (!utils.isNumber(cacheFlushInterval)) {\n\t        throw new Error('cacheFlushInterval must be a number!');\n\t      } else if (cacheFlushInterval < 0) {\n\t        throw new Error('cacheFlushInterval must be greater than zero!');\n\t      } else if (cacheFlushInterval !== _this.$$cacheFlushInterval) {\n\t        _this.$$cacheFlushInterval = cacheFlushInterval;\n\t\n\t        clearInterval(_this.$$cacheFlushIntervalId); // eslint-disable-line\n\t\n\t        _this.$$cacheFlushIntervalId = setInterval(function () {\n\t          _this.removeAll();\n\t        }, _this.$$cacheFlushInterval);\n\t      }\n\t    },\n\t    setCapacity: function setCapacity(capacity) {\n\t      if (capacity === null) {\n\t        delete this.$$capacity;\n\t      } else if (!utils.isNumber(capacity)) {\n\t        throw new Error('capacity must be a number!');\n\t      } else if (capacity < 0) {\n\t        throw new Error('capacity must be greater than zero!');\n\t      } else {\n\t        this.$$capacity = capacity;\n\t      }\n\t      var removed = {};\n\t      while ($$lruHeap.size() > this.$$capacity) {\n\t        removed[$$lruHeap.peek().key] = this.remove($$lruHeap.peek().key);\n\t      }\n\t      return removed;\n\t    },\n\t    setDeleteOnExpire: function setDeleteOnExpire(deleteOnExpire, setRecycleFreq) {\n\t      if (deleteOnExpire === null) {\n\t        delete this.$$deleteOnExpire;\n\t      } else if (!utils.isString(deleteOnExpire)) {\n\t        throw new Error('deleteOnExpire must be a string!');\n\t      } else if (deleteOnExpire !== 'none' && deleteOnExpire !== 'passive' && deleteOnExpire !== 'aggressive') {\n\t        throw new Error('deleteOnExpire must be \"none\", \"passive\" or \"aggressive\"!');\n\t      } else {\n\t        this.$$deleteOnExpire = deleteOnExpire;\n\t      }\n\t      if (setRecycleFreq !== false) {\n\t        this.setRecycleFreq(this.$$recycleFreq);\n\t      }\n\t    },\n\t    setMaxAge: function setMaxAge(maxAge) {\n\t      if (maxAge === null) {\n\t        this.$$maxAge = Number.MAX_VALUE;\n\t      } else if (!utils.isNumber(maxAge)) {\n\t        throw new Error('maxAge must be a number!');\n\t      } else if (maxAge < 0) {\n\t        throw new Error('maxAge must be greater than zero!');\n\t      } else {\n\t        this.$$maxAge = maxAge;\n\t      }\n\t      var i = undefined,\n\t          keys = undefined,\n\t          key = undefined;\n\t\n\t      $$expiresHeap.removeAll();\n\t\n\t      if ($$storage) {\n\t        var keysJson = $$storage().getItem(this.$$prefix + '.keys');\n\t\n\t        keys = keysJson ? utils.fromJson(keysJson) : [];\n\t\n\t        for (i = 0; i < keys.length; i++) {\n\t          key = keys[i];\n\t          var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);\n\t\n\t          if (itemJson) {\n\t            var item = utils.fromJson(itemJson);\n\t            if (this.$$maxAge === Number.MAX_VALUE) {\n\t              item.expires = Number.MAX_VALUE;\n\t            } else {\n\t              item.expires = item.created + (item.maxAge || this.$$maxAge);\n\t            }\n\t            $$expiresHeap.push({\n\t              key: key,\n\t              expires: item.expires\n\t            });\n\t          }\n\t        }\n\t      } else {\n\t        keys = _keys($$data);\n\t\n\t        for (i = 0; i < keys.length; i++) {\n\t          key = keys[i];\n\t          if (this.$$maxAge === Number.MAX_VALUE) {\n\t            $$data[key].expires = Number.MAX_VALUE;\n\t          } else {\n\t            $$data[key].expires = $$data[key].created + ($$data[key].maxAge || this.$$maxAge);\n\t          }\n\t          $$expiresHeap.push($$data[key]);\n\t        }\n\t      }\n\t      if (this.$$deleteOnExpire === 'aggressive') {\n\t        return this.removeExpired();\n\t      } else {\n\t        return {};\n\t      }\n\t    },\n\t    setOnExpire: function setOnExpire(onExpire) {\n\t      if (onExpire === null) {\n\t        delete this.$$onExpire;\n\t      } else if (!utils.isFunction(onExpire)) {\n\t        throw new Error('onExpire must be a function!');\n\t      } else {\n\t        this.$$onExpire = onExpire;\n\t      }\n\t    },\n\t    setOptions: function setOptions(cacheOptions, strict) {\n\t      cacheOptions = cacheOptions || {};\n\t      strict = !!strict;\n\t      if (!utils.isObject(cacheOptions)) {\n\t        throw new Error('cacheOptions must be an object!');\n\t      }\n\t\n\t      if ('storagePrefix' in cacheOptions) {\n\t        this.$$storagePrefix = cacheOptions.storagePrefix;\n\t      } else if (strict) {\n\t        this.$$storagePrefix = defaults.storagePrefix;\n\t      }\n\t\n\t      this.$$prefix = this.$$storagePrefix + this.$$id;\n\t\n\t      if ('disabled' in cacheOptions) {\n\t        this.$$disabled = !!cacheOptions.disabled;\n\t      } else if (strict) {\n\t        this.$$disabled = defaults.disabled;\n\t      }\n\t\n\t      if ('deleteOnExpire' in cacheOptions) {\n\t        this.setDeleteOnExpire(cacheOptions.deleteOnExpire, false);\n\t      } else if (strict) {\n\t        this.setDeleteOnExpire(defaults.deleteOnExpire, false);\n\t      }\n\t\n\t      if ('recycleFreq' in cacheOptions) {\n\t        this.setRecycleFreq(cacheOptions.recycleFreq);\n\t      } else if (strict) {\n\t        this.setRecycleFreq(defaults.recycleFreq);\n\t      }\n\t\n\t      if ('maxAge' in cacheOptions) {\n\t        this.setMaxAge(cacheOptions.maxAge);\n\t      } else if (strict) {\n\t        this.setMaxAge(defaults.maxAge);\n\t      }\n\t\n\t      if ('storeOnResolve' in cacheOptions) {\n\t        this.$$storeOnResolve = !!cacheOptions.storeOnResolve;\n\t      } else if (strict) {\n\t        this.$$storeOnResolve = defaults.storeOnResolve;\n\t      }\n\t\n\t      if ('storeOnReject' in cacheOptions) {\n\t        this.$$storeOnReject = !!cacheOptions.storeOnReject;\n\t      } else if (strict) {\n\t        this.$$storeOnReject = defaults.storeOnReject;\n\t      }\n\t\n\t      if ('capacity' in cacheOptions) {\n\t        this.setCapacity(cacheOptions.capacity);\n\t      } else if (strict) {\n\t        this.setCapacity(defaults.capacity);\n\t      }\n\t\n\t      if ('cacheFlushInterval' in cacheOptions) {\n\t        this.setCacheFlushInterval(cacheOptions.cacheFlushInterval);\n\t      } else if (strict) {\n\t        this.setCacheFlushInterval(defaults.cacheFlushInterval);\n\t      }\n\t\n\t      if ('onExpire' in cacheOptions) {\n\t        this.setOnExpire(cacheOptions.onExpire);\n\t      } else if (strict) {\n\t        this.setOnExpire(defaults.onExpire);\n\t      }\n\t\n\t      if ('storageMode' in cacheOptions || 'storageImpl' in cacheOptions) {\n\t        this.setStorageMode(cacheOptions.storageMode || defaults.storageMode, cacheOptions.storageImpl || defaults.storageImpl);\n\t      } else if (strict) {\n\t        this.setStorageMode(defaults.storageMode, defaults.storageImpl);\n\t      }\n\t    },\n\t    setRecycleFreq: function setRecycleFreq(recycleFreq) {\n\t      if (recycleFreq === null) {\n\t        delete this.$$recycleFreq;\n\t      } else if (!utils.isNumber(recycleFreq)) {\n\t        throw new Error('recycleFreq must be a number!');\n\t      } else if (recycleFreq < 0) {\n\t        throw new Error('recycleFreq must be greater than zero!');\n\t      } else {\n\t        this.$$recycleFreq = recycleFreq;\n\t      }\n\t      clearInterval(this.$$recycleFreqId);\n\t      if (this.$$deleteOnExpire === 'aggressive') {\n\t        (function (self) {\n\t          self.$$recycleFreqId = setInterval(function () {\n\t            self.removeExpired();\n\t          }, self.$$recycleFreq);\n\t        })(this);\n\t      } else {\n\t        delete this.$$recycleFreqId;\n\t      }\n\t    },\n\t    setStorageMode: function setStorageMode(storageMode, storageImpl) {\n\t      if (!utils.isString(storageMode)) {\n\t        throw new Error('storageMode must be a string!');\n\t      } else if (storageMode !== 'memory' && storageMode !== 'localStorage' && storageMode !== 'sessionStorage') {\n\t        throw new Error('storageMode must be \"memory\", \"localStorage\" or \"sessionStorage\"!');\n\t      }\n\t\n\t      var prevStorage = $$storage;\n\t      var prevData = $$data;\n\t      var shouldReInsert = false;\n\t      var items = {};\n\t\n\t      function load(prevStorage, prevData) {\n\t        var keys = this.keys();\n\t        var length = keys.length;\n\t        if (length) {\n\t          var _key = undefined;\n\t          var prevDataIsObject = utils.isObject(prevData);\n\t          for (var i = 0; i < length; i++) {\n\t            _key = keys[i];\n\t            if (prevStorage) {\n\t              var itemJson = prevStorage().getItem(this.$$prefix + '.data.' + _key);\n\t              if (itemJson) {\n\t                items[_key] = utils.fromJson(itemJson);\n\t              }\n\t            } else if (prevDataIsObject) {\n\t              items[_key] = prevData[_key];\n\t            }\n\t            this.remove(_key);\n\t          }\n\t          shouldReInsert = true;\n\t        }\n\t      }\n\t\n\t      if (!this.$$initializing) {\n\t        load.call(this, prevStorage, prevData);\n\t      }\n\t\n\t      this.$$storageMode = storageMode;\n\t\n\t      if (storageImpl) {\n\t        if (!utils.isObject(storageImpl)) {\n\t          throw new Error('storageImpl must be an object!');\n\t        } else if (!('setItem' in storageImpl) || typeof storageImpl.setItem !== 'function') {\n\t          throw new Error('storageImpl must implement \"setItem(key, value)\"!');\n\t        } else if (!('getItem' in storageImpl) || typeof storageImpl.getItem !== 'function') {\n\t          throw new Error('storageImpl must implement \"getItem(key)\"!');\n\t        } else if (!('removeItem' in storageImpl) || typeof storageImpl.removeItem !== 'function') {\n\t          throw new Error('storageImpl must implement \"removeItem(key)\"!');\n\t        }\n\t        $$storage = function $$storage() {\n\t          return storageImpl;\n\t        };\n\t      } else if (this.$$storageMode === 'localStorage') {\n\t        try {\n\t          localStorage.setItem('cachefactory', 'cachefactory');\n\t          localStorage.removeItem('cachefactory');\n\t          $$storage = function $$storage() {\n\t            return localStorage;\n\t          };\n\t        } catch (e) {\n\t          $$storage = null;\n\t          this.$$storageMode = 'memory';\n\t        }\n\t      } else if (this.$$storageMode === 'sessionStorage') {\n\t        try {\n\t          sessionStorage.setItem('cachefactory', 'cachefactory');\n\t          sessionStorage.removeItem('cachefactory');\n\t          $$storage = function $$storage() {\n\t            return sessionStorage;\n\t          };\n\t        } catch (e) {\n\t          $$storage = null;\n\t          this.$$storageMode = 'memory';\n\t        }\n\t      } else {\n\t        $$storage = null;\n\t        this.$$storageModel = 'memory';\n\t      }\n\t\n\t      if (this.$$initializing) {\n\t        load.call(this, $$storage, $$data);\n\t      }\n\t\n\t      if (shouldReInsert) {\n\t        var item = undefined;\n\t        for (var key in items) {\n\t          item = items[key];\n\t          this.put(key, item.value, {\n\t            created: item.created,\n\t            accessed: item.accessed,\n\t            expires: item.expires\n\t          });\n\t        }\n\t      }\n\t    },\n\t    touch: function touch(key) {\n\t      var _this4 = this;\n\t\n\t      if (key) {\n\t        var val = this.get(key, {\n\t          onExpire: function onExpire(k, v) {\n\t            return _this4.put(k, v);\n\t          }\n\t        });\n\t        if (val) {\n\t          this.put(key, val);\n\t        }\n\t      } else {\n\t        var keys = this.keys();\n\t        for (var i = 0; i < keys.length; i++) {\n\t          this.touch(keys[i]);\n\t        }\n\t      }\n\t    },\n\t    values: function values() {\n\t      var keys = this.keys();\n\t      var items = [];\n\t      for (var i = 0; i < keys.length; i++) {\n\t        items.push(this.get(keys[i]));\n\t      }\n\t      return items;\n\t    }\n\t  };\n\t\n\t  cache.$$initializing = true;\n\t  cache.setOptions(options, true);\n\t  cache.$$initializing = false;\n\t\n\t  return cache;\n\t}\n\t\n\tfunction CacheFactory(cacheId, options) {\n\t  return createCache(cacheId, options);\n\t}\n\t\n\tCacheFactory.createCache = createCache;\n\tCacheFactory.defaults = defaults;\n\t\n\tCacheFactory.info = function () {\n\t  var keys = _keys(caches);\n\t  var info = {\n\t    size: keys.length,\n\t    caches: {}\n\t  };\n\t  for (var opt in defaults) {\n\t    if (defaults.hasOwnProperty(opt)) {\n\t      info[opt] = defaults[opt];\n\t    }\n\t  }\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    info.caches[key] = caches[key].info();\n\t  }\n\t  return info;\n\t};\n\t\n\tCacheFactory.get = function (cacheId) {\n\t  return caches[cacheId];\n\t};\n\tCacheFactory.keySet = function () {\n\t  return _keySet(caches);\n\t};\n\tCacheFactory.keys = function () {\n\t  return _keys(caches);\n\t};\n\tCacheFactory.destroy = function (cacheId) {\n\t  if (caches[cacheId]) {\n\t    caches[cacheId].destroy();\n\t    delete caches[cacheId];\n\t  }\n\t};\n\tCacheFactory.destroyAll = function () {\n\t  for (var cacheId in caches) {\n\t    caches[cacheId].destroy();\n\t  }\n\t  caches = {};\n\t};\n\tCacheFactory.clearAll = function () {\n\t  for (var cacheId in caches) {\n\t    caches[cacheId].removeAll();\n\t  }\n\t};\n\tCacheFactory.removeExpiredFromAll = function () {\n\t  var expired = {};\n\t  for (var cacheId in caches) {\n\t    expired[cacheId] = caches[cacheId].removeExpired();\n\t  }\n\t  return expired;\n\t};\n\tCacheFactory.enableAll = function () {\n\t  for (var cacheId in caches) {\n\t    caches[cacheId].$$disabled = false;\n\t  }\n\t};\n\tCacheFactory.disableAll = function () {\n\t  for (var cacheId in caches) {\n\t    caches[cacheId].$$disabled = true;\n\t  }\n\t};\n\tCacheFactory.touchAll = function () {\n\t  for (var cacheId in caches) {\n\t    caches[cacheId].touch();\n\t  }\n\t};\n\t\n\tCacheFactory.utils = utils;\n\tCacheFactory.BinaryHeap = BinaryHeap;\n\t\n\tmodule.exports = CacheFactory;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * yabh\n\t * @version 1.1.0 - Homepage <http://jmdobry.github.io/yabh/>\n\t * @author Jason Dobry <jason.dobry@gmail.com>\n\t * @copyright (c) 2015 Jason Dobry \n\t * @license MIT <https://github.com/jmdobry/yabh/blob/master/LICENSE>\n\t * \n\t * @overview Yet another Binary Heap.\n\t */\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"yabh\", factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"BinaryHeap\"] = factory();\n\t\telse\n\t\t\troot[\"BinaryHeap\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/**\n\t\t * @method bubbleUp\n\t\t * @param {array} heap The heap.\n\t\t * @param {function} weightFunc The weight function.\n\t\t * @param {number} n The index of the element to bubble up.\n\t\t */\n\t\tfunction bubbleUp(heap, weightFunc, n) {\n\t\t  var element = heap[n];\n\t\t  var weight = weightFunc(element);\n\t\t  // When at 0, an element can not go up any further.\n\t\t  while (n > 0) {\n\t\t    // Compute the parent element's index, and fetch it.\n\t\t    var parentN = Math.floor((n + 1) / 2) - 1;\n\t\t    var _parent = heap[parentN];\n\t\t    // If the parent has a lesser weight, things are in order and we\n\t\t    // are done.\n\t\t    if (weight >= weightFunc(_parent)) {\n\t\t      break;\n\t\t    } else {\n\t\t      heap[parentN] = element;\n\t\t      heap[n] = _parent;\n\t\t      n = parentN;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\t/**\n\t\t * @method bubbleDown\n\t\t * @param {array} heap The heap.\n\t\t * @param {function} weightFunc The weight function.\n\t\t * @param {number} n The index of the element to sink down.\n\t\t */\n\t\tvar bubbleDown = function bubbleDown(heap, weightFunc, n) {\n\t\t  var length = heap.length;\n\t\t  var node = heap[n];\n\t\t  var nodeWeight = weightFunc(node);\n\t\n\t\t  while (true) {\n\t\t    var child2N = (n + 1) * 2,\n\t\t        child1N = child2N - 1;\n\t\t    var swap = null;\n\t\t    if (child1N < length) {\n\t\t      var child1 = heap[child1N],\n\t\t          child1Weight = weightFunc(child1);\n\t\t      // If the score is less than our node's, we need to swap.\n\t\t      if (child1Weight < nodeWeight) {\n\t\t        swap = child1N;\n\t\t      }\n\t\t    }\n\t\t    // Do the same checks for the other child.\n\t\t    if (child2N < length) {\n\t\t      var child2 = heap[child2N],\n\t\t          child2Weight = weightFunc(child2);\n\t\t      if (child2Weight < (swap === null ? nodeWeight : weightFunc(heap[child1N]))) {\n\t\t        swap = child2N;\n\t\t      }\n\t\t    }\n\t\n\t\t    if (swap === null) {\n\t\t      break;\n\t\t    } else {\n\t\t      heap[n] = heap[swap];\n\t\t      heap[swap] = node;\n\t\t      n = swap;\n\t\t    }\n\t\t  }\n\t\t};\n\t\n\t\tfunction BinaryHeap(weightFunc, compareFunc) {\n\t\t  if (!weightFunc) {\n\t\t    weightFunc = function (x) {\n\t\t      return x;\n\t\t    };\n\t\t  }\n\t\t  if (!compareFunc) {\n\t\t    compareFunc = function (x, y) {\n\t\t      return x === y;\n\t\t    };\n\t\t  }\n\t\t  if (typeof weightFunc !== 'function') {\n\t\t    throw new Error('BinaryHeap([weightFunc][, compareFunc]): \"weightFunc\" must be a function!');\n\t\t  }\n\t\t  if (typeof compareFunc !== 'function') {\n\t\t    throw new Error('BinaryHeap([weightFunc][, compareFunc]): \"compareFunc\" must be a function!');\n\t\t  }\n\t\t  this.weightFunc = weightFunc;\n\t\t  this.compareFunc = compareFunc;\n\t\t  this.heap = [];\n\t\t}\n\t\n\t\tvar BHProto = BinaryHeap.prototype;\n\t\n\t\tBHProto.push = function (node) {\n\t\t  this.heap.push(node);\n\t\t  bubbleUp(this.heap, this.weightFunc, this.heap.length - 1);\n\t\t};\n\t\n\t\tBHProto.peek = function () {\n\t\t  return this.heap[0];\n\t\t};\n\t\n\t\tBHProto.pop = function () {\n\t\t  var front = this.heap[0];\n\t\t  var end = this.heap.pop();\n\t\t  if (this.heap.length > 0) {\n\t\t    this.heap[0] = end;\n\t\t    bubbleDown(this.heap, this.weightFunc, 0);\n\t\t  }\n\t\t  return front;\n\t\t};\n\t\n\t\tBHProto.remove = function (node) {\n\t\t  var length = this.heap.length;\n\t\t  for (var i = 0; i < length; i++) {\n\t\t    if (this.compareFunc(this.heap[i], node)) {\n\t\t      var removed = this.heap[i];\n\t\t      var end = this.heap.pop();\n\t\t      if (i !== length - 1) {\n\t\t        this.heap[i] = end;\n\t\t        bubbleUp(this.heap, this.weightFunc, i);\n\t\t        bubbleDown(this.heap, this.weightFunc, i);\n\t\t      }\n\t\t      return removed;\n\t\t    }\n\t\t  }\n\t\t  return null;\n\t\t};\n\t\n\t\tBHProto.removeAll = function () {\n\t\t  this.heap = [];\n\t\t};\n\t\n\t\tBHProto.size = function () {\n\t\t  return this.heap.length;\n\t\t};\n\t\n\t\tmodule.exports = BinaryHeap;\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=cachefactory.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../CacheFactory/dist/cachefactory.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}